/**
 * Created by shadygabal on 10/22/15.
 */
/* Setup */
var mongoose = require('./mongoose_connect.js');
var Schema = mongoose.Schema;
var ObjectId = Schema.Types.ObjectId;
var ObjectIdConstructor = mongoose.Types.ObjectId;


/* Other Models */
//var Business = require('./Business.js');
var User = require('./User.js');
var Soiree = require('./Soiree.js');
var SoireeReservation = require('./SoireeReservation.js');

var Admin = require('./Admin.js');

/* Packages */
var shortid = require('shortid');
var bcrypt = require('bcrypt');


/* Schema Specific */
var businessTypes = ["Bar", "Restaurant", "Cafe"];
var tags = ["vegan options", "vegetarian options", "outdoor seating"];
/* Helpers */
var helpersFolderLocation = "../helpers/";
var DateHelper = require('app/helpers/DateHelper.js');
var ResHelper = require('app/helpers/ResHelper.js');
var CreditCardHelper = require('app/helpers/CreditCardHelper.js');
var LocationHelper = require('app/helpers/LocationHelper.js');
var PushNotificationHelper = require('app/helpers/PushNotificationHelper.js');
var IdGeneratorHelper = require('app/helpers/IdGeneratorHelper.js');
var EmailHelper = require('app/helpers/EmailHelper.js');

var ErrorCodes = require('app/helpers/ErrorCodes.js');
var Globals = require('app/helpers/Globals.js');
var SubwayLine = require('app/db/SubwayLine.js');

var uniqueValidator = require('mongoose-unique-validator');

var businessSchema = new Schema({
        businessType : {type: String, enum: businessTypes},
        businessName : {type: String, required: [true, "Business must have a name"]},
        businessId: {type: String, index: true, unique:true},
        _soirees : [{type: ObjectId, ref:"Soiree"}],
        _unconfirmedReservations : [{type: ObjectId, ref:"SoireeReservation"}],
        _confirmedReservations : [{type: ObjectId, ref:"SoireeReservation"}],
        location: {
            type: {type: String},
            coordinates: []
        },
        soireeTypes : [{type: String, lowercase: true, trim: true, enum: Globals.soireeTypes}],
        address : {type: String, required: [true, "Address required"]},
        phoneNumber : {type: String, required: [true, "Phone number required"], unique: true},
        generalArea : {type: String},
        numSoireesHosted : {type: Number, default: 0},
        _approvedBy: {type: ObjectId, ref: "Admin"},
        email : {type: String, required: [true, "Email address required"], index: true, unique: true, uniqueCaseInsensitive: true},
        password : {type: String, required: [true, "Password required"]},
        classType : {type: String, default: "business", enum: ['business']},
        tags : [{type: String, enum: tags}],
        subwayLinesNear : [{type: String}],

    },
    { timestamps: { createdAt: 'dateCreated', updatedAt: 'dateUpdated' } }
);

businessSchema.index({location: '2dsphere'}, {unique: false});


businessSchema.statics.createBusiness = function(business, email, password, admin, successCallback, errorCallback){
    if (!admin){
        return errorCallback(ErrorCodes.MissingData);
    }
    var Business = this;

    //if no email or password return
    if (!email || !password){
        console.log("No username/pw specified in createBusiness()");
        return errorCallback(ErrorCodes.MissingData);
    }

    business.email = email;
    business._approvedBy = admin._id;

    var location = LocationHelper.locationFromCoordinatesArray(business.location.coordinates);

    SubwayLine.findLinesNearLocation(location, function(lines){

        business.subwayLinesNear = lines;

        //create salt
        bcrypt.genSalt(Globals.SALT_LENGTH, function(err, salt) {
            if (err){
                console.log("Error creating salt - Business.createBusiness()");
                return errorCallback(ErrorCodes.Error);
            }

            //use salt to hash password
            bcrypt.hash(password, salt, function(err, hash) {
                if (err){
                    console.log("Error generating password hash - createBusiness()");
                    return errorCallback(ErrorCodes.Error);
                }

                // Store hash in your password DB.
                business.password = hash;

                var newBusiness = new Business(business);

                newBusiness.save(function(err, savedBusiness){
                    if (err){
                        console.log("Error saving new business - createBusiness(): " + err);
                        return errorCallback(err);
                    }
                    else{
                        EmailHelper.sendBusinessRegisteredEmail(savedBusiness, password, function(){
                            successCallback(savedBusiness);
                        }, function(err){
                            savedBusiness.remove();
                            errorCallback(err);
                        });
                    }
                });
            });
        });

    }, errorCallback);


};

businessSchema.statics.nextBusinessToHostSoiree = function(soireeType, successCallback, errorCallback){
    if (!soireeType){
        return errorCallback(ErrorCodes.MissingData);
    }

    this.find({"soireeTypes" : soireeType}, function(err, businesses){

        if (err) {
           console.log("Error finding next business to host soiree");
           errorCallback(ErrorCodes.ErrorQuerying);
       }
        else{
           if (!businesses || businesses.length === 0) {
               errorCallback(ErrorCodes.NotFound);
           }
           else {
               var business;
               var min;

               for (var i = 0; i < businesses.length; i++){
                   var curr = businesses[i];

                   var numSoireesHosted;
                   console.log(Globals.numSoireesHostedPerBusiness);

                   if (Globals.numSoireesHostedPerBusiness[curr.businessId]){
                       numSoireesHosted = Globals.numSoireesHostedPerBusiness[curr.businessId];
                   }
                   else{
                       numSoireesHosted = curr.numSoireesHosted;
                       Globals.numSoireesHostedPerBusiness[curr.businessId] = numSoireesHosted;
                   }

                   if (!business || numSoireesHosted < min){
                       business = curr;
                       min = numSoireesHosted;
                   }
               }

               console.log("Found next business to host soiree: " + business.businessName);
               business.numSoireesHosted++;
               Globals.numSoireesHostedPerBusiness[business.businessId]++;
               business.save(Globals.saveErrorCallback);
               successCallback(business);
           }
       }
    });
};

businessSchema.statics.checkIfLoggedIn = function(req, res, next){
    if (!isLoggedIn(req)){
        req.session.returnTo = req.originalUrl;
        res.redirect('/businessLogin');
    }
    else{
        req.business = req.user;
        next();
    }
};

businessSchema.statics.isLoggedIn = function(req){
    return isLoggedIn(req);
};

businessSchema.methods.validatePassword = function(password, callback){
    bcrypt.compare(password, this.password, callback);
};

businessSchema.methods.confirmSoireeReservation = function(reservation, successCallback, errorCallback){
    if (!reservation.confirmed)
        return errorCallback(ErrorCodes.Error);

    //
    //TODO: do backend charging stuff
    //

    //move _id from _unconfirmed to _confirmed
    var index = this._unconfirmedReservations.indexOf(reservation._id);
    if (index !== -1){
        this._unconfirmedReservations.splice(index, 1);
        //var sIndex = this._confirmedReservations.indexOf(reservation._id);
        if (this._confirmedReservations.indexOf(reservation._id) === -1){
            this._confirmedReservations.push(reservation._id);
        }
    }

    this.save(function(err){
        if (err){
            console.log(err);
            errorCallback(ErrorCodes.ErrorSaving);
        }
        else{
            successCallback();
        }

    });
};

businessSchema.methods.findReservationWithConfirmationCode = function(code, successCallback, errorCallback){
    code = code.toUpperCase();

    this.deepPopulate("_unconfirmedReservations", function(err, _business){
    if (err){
        console.log(err);
        return errorCallback(ErrorCodes.ErrorQuerying);
    }
    else{
        for (var i = 0; i < _business._unconfirmedReservations.length; i++){
            var reservation = _business._unconfirmedReservations[i];
            if (reservation.confirmationCode === code){
                return successCallback(reservation);
            }
        }
    }
        return errorCallback(ErrorCodes.NotFound);
  });
};

function isLoggedIn(req){
    if (req.user && req.user.classType === 'business') {
        return true;
    }
    return false;
};

businessSchema.pre('validate', function(next){
    if (!this.businessId){
        IdGeneratorHelper.generateUniqueId("Business", "businessId", this, next);
    }
    else next();
});

businessSchema.pre('remove', function(next){
    //Soiree.find({_business : this._id}).exec(function(err, soirees){
    //    if (err) console.log(err);
    //    else{
    //        soirees.forEach(function(soiree){
    //           soiree.remove();
    //        });
    //    }
    //});
    next();
});


var deepPopulate = require('mongoose-deep-populate')(mongoose);
businessSchema.plugin(deepPopulate, {});
businessSchema.plugin(uniqueValidator, {message: '{PATH} already taken.' });

module.exports = mongoose.model('Business', businessSchema);

