/**
 * Created by shadygabal on 12/3/15.
 */

/* Setup */
var mongoose = require('./mongoose_connect.js');
var Schema = mongoose.Schema;
var ObjectId = Schema.Types.ObjectId;


/* Other Models */
var Business = require('./Business.js');
var User = require('./User.js');
var CommunityPost = require('./CommunityPost.js');

/* Packages */
var shortid = require('shortid');
var autopopulate = require('mongoose-autopopulate');

/* Helpers */
var helpersFolderLocation = "../helpers/";
var DateHelper = require('app/helpers/DateHelper.js');
var ResHelper = require('app/helpers/ResHelper.js');
var CreditCardHelper = require('app/helpers/CreditCardHelper.js');
var LocationHelper = require('app/helpers/LocationHelper.js');
var IDGeneratorHelper = require('app/helpers/IDGeneratorHelper.js');
var PushNotificationHelper = require('app/helpers/PushNotificationHelper.js');
var ErrorCodes = require('app/helpers/ErrorCodes.js');
/* Schema Specific */

var commentSchema = new Schema({
    text : {type: String, required: true},
    commentId: {type: String, index: true, unique: true, required: true},
    //author: {type: String, required: [true, "No author specified"]}, /* Author */
    //authorProfilePictureUrl : {type: String},
    _post: {type: ObjectId, ref:"CommunityPost"},
    _user : {type: ObjectId, ref:"User", autopopulate: {select : "firstName lastName profilePictureUrl userId"}},
    _upvotes : [{type: ObjectId, ref:"User"}],
    _downvotes : [{type: ObjectId, ref:"User"}],
    //dateCreated : {type: Date, default: new Date()}
},
    { timestamps: { createdAt: 'dateCreated', updatedAt: 'dateUpdated' } }
);

commentSchema.methods.jsonObject = function(user){
    var timeIntervalSince1970InSeconds = this.dateCreated.getTime() / 1000.;

    var obj = {
        "text" : this.text,
        "dateCreated": timeIntervalSince1970InSeconds,
        "commentId": this.commentId,
        "score" : this.score
    };

    if (user){
        var upvotedByUser = this._upvotes.indexOf(user._id) !== -1;
        var downvotedByUser = this._downvotes.indexOf(user._id) !== -1;

        obj.upvotedByUser = upvotedByUser;
        obj.downvotedByUser = downvotedByUser;
    }

    if (!this.populated('_user') || !this._user) {
        console.log("WARNING: Did not populate _user when retrieving CommunityComment (or _user is null)");
    }
    else{
        obj["userId"] = this._user.userId;
        obj["author"] = this.author;
        obj["authorProfilePictureUrl"] = this._user.profilePictureUrl;
    }

    return obj;
};

commentSchema.statics.findCommentWithId = function(commentId, successCallback, errorCallback){
    if (!commentId) return errorCallback(ErrorCodes.MissingData);

    var CommunityComment = this;
    CommunityComment.findOne({commentId : commentId}).exec(function(err, comment){
       if (err){
           return errorCallback(ErrorCodes.MongoError);
       }
        else return successCallback(comment);
    });
};

commentSchema.statics.upvoteCommentWithId = function(commentId, user, successCallback, errorCallback) {
    if (!user || !commentId){
        return errorCallback(ErrorCodes.MissingData);
    }

    var updateQuery = {"$addToSet" : {"_upvotes" : user._id} , "$pull" : {"_downvotes" : user._id}};


    this.findOneAndUpdate({commentId : commentId}, updateQuery, {new : true}, function(err, newDoc){
        if (err){
            console.log(err);
            return errorCallback(ErrorCodes.MongoError);
        }
        else{
            successCallback(newDoc);
        }
    });

};

commentSchema.statics.downvoteCommentWithId = function(commentId, user, successCallback, errorCallback) {
    if (!user || !commentId){
        return errorCallback(ErrorCodes.MissingData);
    }

    var updateQuery = {"$pull" : {"_upvotes" : user._id} , "$addToSet" : {"_downvotes" : user._id}};


    this.findOneAndUpdate({commentId : commentId}, updateQuery, {new : true}, function(err, newDoc){
        if (err){
            console.log(err);
            return errorCallback(ErrorCodes.MongoError);
        }
        else{
            successCallback(newDoc);
        }
    });

};

//commentSchema.methods.vote = function(user, vote, successCallback, errorCallback) {
//    if (vote === "love"){
//        this._upvotes.push(user._id);
//    }
//    else if (vote === "laugh"){
//        this._laughs.push(user._id);
//    }
//    else if (vote === "cry"){
//        this._cries.push(user._id);
//    }
//    else if (vote === "angry"){
//        this._angries.push(user._id);
//    }
//
//    this.save(function(err){
//        if (err){
//            errorCallback(ErrorCodes.ErrorSaving);
//        }
//        else{
//            successCallback(this);
//        }
//    });
//
//};

//commentSchema.methods.unemotion = function(user, vote, successCallback, errorCallback) {
//    if (vote === "love"){
//        var index = this._upvotes.indexOf(user._id);
//        if (index != -1) {
//            this._upvotes.splice(index, 1);
//        }
//
//    }
//    //else if (vote === "laugh"){
//    //    var index = this._laughs.indexOf(user._id);
//    //    if (index != -1) {
//    //        this._laughs.splice(index, 1);
//    //    }
//    //}
//    //else if (vote === "cry"){
//    //    var index = this._cries.indexOf(user._id);
//    //    if (index != -1) {
//    //        this._cries.splice(index, 1);
//    //    }    }
//    else if (vote === "angry"){
//        var index = this._angries.indexOf(user._id);
//        if (index != -1) {
//            this._angries.splice(index, 1);
//        }
//    }
//
//    this.save(function(err, comment){
//        if (err){
//            console.log(err);
//            errorCallback(ErrorCodes.ErrorSaving);
//        }
//        else{
//            successCallback(this, comment);
//        }
//    });
//
//};
//


//commentSchema.virtual('numLoves').get(function () {
//    return this._upvotes.length;
//});
//
//commentSchema.virtual('numLaughs').get(function () {
//    return this._laughs.length;
//});
//
//commentSchema.virtual('numAngries').get(function () {
//    return this._angries.length;
//});

//commentSchema.virtual('numVotes').get(function () {
//    return this._angries.length + this._cries.length + this._laughs.length + this._upvotes.length;
//});

commentSchema.virtual('score').get(function () {
    return this._upvotes.length - this._downvotes.length;
});

commentSchema.virtual('author').get(function () {
    return this._user.fullName;
});

commentSchema.pre("validate", function(next) {
    if (!this.commentId){
        console.log('pre validate - creating unique comment id');
        IDGeneratorHelper.generateUniqueId("CommunityComment", "commentId", this, next, {length : 15, addLowerCase : true});
    }
    else next();
});


commentSchema.pre("save", function(next){
    next();
});

var deepPopulate = require('mongoose-deep-populate')(mongoose);
var options = {};
commentSchema.plugin(deepPopulate, options);
commentSchema.plugin(autopopulate);

module.exports = mongoose.model('CommunityComment', commentSchema);
