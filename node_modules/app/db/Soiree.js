/* Setup */
var mongoose = require('./mongoose_connect.js');
var Schema = mongoose.Schema;
var ObjectId = Schema.Types.ObjectId;

/* Other Models */


/* Packages */
var shortid = require('shortid');
var _ = require("underscore");
var util = require('util');

/* Helper */
var helpersFolderLocation = "../helpers/";
var Globals = require('app/helpers/Globals.js');
var DateHelper = require('app/helpers/DateHelper.js');
var ResHelper = require('app/helpers/ResHelper.js');
var CreditCardHelper = require('app/helpers/CreditCardHelper.js');
var ArrayHelper = require('app/helpers/ArrayHelper.js');
var LocationHelper = require('app/helpers/LocationHelper.js');
var PushNotificationHelper = require('app/helpers/PushNotificationHelper.js');
var Notification = require('app/db/Notification.js');
var math = require('mathjs');
var autopopulate = require('mongoose-autopopulate');


/* Defaults */
//var numUsersMaxPerSoireeType = { "lunch" : 4, "dinner" : 4, "drinks" : 6, "blind date" : 2 };

var AVERAGE_SOIREE_DURATION = 45;
var MIN_TIME_BEFORE_CAN_CREATE_SOIREE = 0;//1.5 * 60 * 60 * 1000
/* Error Codes */
var ErrorCodes = require('app/helpers/ErrorCodes.js');

var timeCountsPerSoireeType = {};

var soireeSchema = new Schema({
		soireeType: {type: String, required: true, enum: Globals.soireeTypes, lowercase: true, trim: true},
		soireeDescription: {type: String},
		category : {type: String},
		title : {type: String},
		numUsersMax: {type: Number, required: true},
		numUsersMin: {type: Number, required: true},
		scheduledStartTimeIdentifier: {type: String},
		scheduledEndTimeIdentifier: {type: String},
		soireeId: {type: String, index: true, default: shortid.generate},
		initialCharge: {type: Number, required: [true, "Forgot to include how much soiree will cost"]}, //in cents
		date: {type: Date, required: [true, "A date for the Soiree is required"]},
		_usersAttending: [{type: ObjectId, ref: "User"}],
		_usersUncharged: [{type: ObjectId, ref: "User"}],
		_business: {
			type: ObjectId,
			ref: "Business",
			required: [true, "A business that will host is required to create this Soiree"],
			autopopulate: true
		},
		location: {
			type: {type: String},
			coordinates: []
		},
		photoIndexIdentifier: {type: Number, default: generatePhotoIndexIdentifier},
		started: {type: Boolean, default: false},
		subwayLinesNear : [{type : String}],
		ended: {type: Boolean, default: false},
		openToUsers: {type: Boolean, default: false},
		cancelled: {type: Boolean, default: false},
		duration: {type: Number, default: AVERAGE_SOIREE_DURATION},
		_unchargedReservations: [{type: ObjectId, ref: "SoireeReservation"}],
		_chargedReservations: [{type: ObjectId, ref: "SoireeReservation"}],
		_host: {type: ObjectId, ref: "SoireeHost"}
	}, {
			timestamps: {createdAt: 'dateCreated', updatedAt: 'dateUpdated'},
			discriminatorKey: '_type'
		}
);

soireeSchema.index({location: '2dsphere'}, {unique: false});

soireeSchema.statics.SOIREE = "Soirée";
soireeSchema.statics.SOIREE_LOWERCASE = "soirée";
soireeSchema.statics.AVERAGE_SOIREE_DURATION = AVERAGE_SOIREE_DURATION;
soireeSchema.statics.AVERAGE_SOIREE_DURATION_IN_MS = AVERAGE_SOIREE_DURATION * 60 * 1000;


function generatePhotoIndexIdentifier() {
	var rand = parseInt(Math.random() * 1000);
	return rand;
};


/* Static Methods */
soireeSchema.methods.jsonObject = function (user) {
	var timeIntervalSince1970InSeconds = this.date.getTime() / 1000;

	var business = this._business ? this._business : {};

	var obj = {
		"soireeType": capitalizeAndClean(this.soireeType),
		"numUsersAttending": this.numUsersAttending,
		"numUsersMax": this.numUsersMax,
		"date": timeIntervalSince1970InSeconds,
		"soireeId": this.soireeId,
		"started": this.started,
		"ended": this.ended,
		"inProgress": this.inProgress,
		"businessName": business.businessName,
		"businessGeneralArea": business.generalArea,
		"coordinates": LocationHelper.locationFromCoordinatesArray(this.location.coordinates),
		"initialCharge": this.initialCharge,
		"photoIndexIdentifier": this.photoIndexIdentifier,
		"reachedNumUsersMin": this.reachedNumUsersMin,
		"willReachNumUsersMin": this.willReachNumUsersMin,
		"soireeDescription": this.soireeDescription,
		"numUsersMin": this.numUsersMin,
		"openToUsers": this.openToUsers,
		"subwayLinesNear" : this.subwayLinesNear ? this.subwayLinesNear : [],
		"title" : this.title,
		"category" : this.category
	};

	if (user) {
		obj.userAlreadyJoined = this.hasUserAlreadyJoined(user);
		if (obj.userAlreadyJoined){
			obj.businessAddress = this.businessAddress
		}
	}

	return obj;
};

soireeSchema.statics.createScheduledTimeIdentifier = function (date) {
	if (!date) {
		date = new Date();
	}
	if (date.constructor != Date) {
		date = new Date(date);
	}

	var year = date.getFullYear();
	var month = addZeroIfNecessary(date.getMonth() + 1);
	var day = addZeroIfNecessary(date.getDate());

	var hours = addZeroIfNecessary(date.getHours());

	var mins = date.getMinutes();
	//round mins to nearest 10
	if (date.getSeconds() >= 30)
		mins = mins + 1;
	mins -= (mins % 10);
	mins = addZeroIfNecessary(mins);

	return "" + year + "." + month + "." + day + "." + hours + "." + mins;
};

function addZeroIfNecessary(num) {
	if (num < 10) {
		return '0' + num;
	}
	return '' + num;
}

soireeSchema.statics.createScheduledTimeIdentifierPast = function (mins) {
	return this.createScheduledTimeIdentifier(Date.now() - (mins * 60 * 1000));
};

soireeSchema.statics.createScheduledTimeIdentifierFuture = function (mins) {
	return this.createScheduledTimeIdentifier(Date.now() + (mins * 60 * 1000));
};

soireeSchema.statics.findNextSoiree = function (user, idsToIgnore, successCallback, errorCallback) {
	if (!idsToIgnore) idsToIgnore = [];
	var today = new Date();
	//var college = user.college;
	//console.log('college: ' + college);

	this.find({
		cancelled: false,
		ended: false,
		started: false,
		_usersAttending: {"$ne": user._id},
		_usersUncharged: {"$ne": user._id},
		soireeId: {"$nin": idsToIgnore},
		date: {"$gte": today}
	}).sort({"date": 1}).limit(1).exec(function (err, soirees) {

		if (err || !soirees) {
			console.log("error finding next soiree: " + err);
			errorCallback(ErrorCodes.MongoError);
		}
		else {
			//console.log("found soirees: " + soirees);
			if (soirees.length === 0) {
				successCallback(null);
			}
			else successCallback(soirees[0]);
		}
	});

};

function capitalizeAndClean(str) {
	str = str.replace(/_/g, " ");
	return str.replace(/(^|\s)([a-z])/g, function (m, p1, p2) {
		return p1 + p2.toUpperCase();
	});
};


soireeSchema.statics.setSoireeDefaults = function (soiree, successCallback, errorCallback, options) {
	var Soiree = this;
	var Business = mongoose.model("Business");
	
	if (!options) options = {};

	var initialCharge = soiree.initialCharge ? soiree.initialCharge : options.initialCharge;
	var numUsersMax = soiree.numUsersMax ? soiree.numUsersMax : options.numUsersMax;
	var numUsersMin = soiree.numUsersMin ? soiree.numUsersMin : options.numUsersMin;
	var business = soiree._business ? soiree._business : options.business;

	if (!numUsersMax) {
		numUsersMax = Globals.numUsersMaxPerSoireeType[soiree.soireeType];
	}
	if (!numUsersMin) {
		numUsersMin = Globals.numUsersMinPerSoireeType[soiree.soireeType];
	}
	if (!initialCharge) {
		initialCharge = Globals.initialChargePerSoireeType[soiree.soireeType];
	}
	if (!soiree.category){
		soiree.category = Globals.soireeCategoriesPerSoireeType[soiree.soireeType] ? Globals.soireeCategoriesPerSoireeType[soiree.soireeType] : soiree.soireeType;
	}

	soiree.initialCharge = initialCharge;
	soiree.numUsersMax = numUsersMax;
	soiree.numUsersMin = numUsersMin;

	if (soiree.date) {
		var hoursMinsString = DateHelper.timeStringFromDate(soiree.date);

		if (soiree.soireeType != "test") {
			//console.log("increasing count of [" + soiree.soireeType + "][" + hoursMinsString + "] from " + timeCountsPerSoireeType[soiree.soireeType][hoursMinsString]);

			//timeCountsPerSoireeType[soiree.soireeType][hoursMinsString]++;

			//console.log("to " + timeCountsPerSoireeType[soiree.soireeType][hoursMinsString]);
		}
	}

	if (business) {
		saveSoireeWithBusiness(soiree, business, successCallback, errorCallback);
	}
	else {
		Business.nextBusinessToHostSoiree(soiree.soireeType, function (_business) {
			if (!_business) {
				return errorCallback(ErrorCodes.NotFound);
			}

			saveSoireeWithBusiness(soiree, _business, successCallback, errorCallback);
		}, function (err) {
			errorCallback(err);
		});
	}
};

function saveSoireeWithBusiness(soiree, business, successCallback, errorCallback) {

	if (business.soireeTypes.indexOf(soiree.soireeType) === -1) {
		return errorCallback(ErrorCodes.InvalidInput);
	}

	business.createdNewSoiree(soiree);

	soiree._business = business._id;
	soiree.location = business.location;
	soiree.subwayLinesNear = business.subwayLinesNear;


	soiree.save(function (err, savedSoiree) {
		if (err) {
			console.log(err);
			if(errorCallback) errorCallback(ErrorCodes.ErrorSaving);
		}
		else {
			console.log('saved soiree with id ' + savedSoiree.soireeId);
			if (successCallback) successCallback(savedSoiree);
		}
	});
};

soireeSchema.statics.findSoireesForBusiness = function (business, options, successCallback, errorCallback) {
	if (!business)
		return errorCallback(ErrorCodes.MissingData);

	_.defaults(options, {showExpired: false, sameDay: false});

	this.find({"_business": business._id}).deepPopulate("_usersAttending").exec(function (err, soirees) {
		if (err) {
			console.log(err);
			errorCallback(ErrorCodes.ErrorQuerying);
		}
		else {
			successCallback(soirees);
		}
	});
};

soireeSchema.statics.createAppropriateSoiree = function () {
	var date = new Date();
	var hour = date.getHours();

};


soireeSchema.statics.fillTimeCountsPerSoireeType = function () {
	//for (var i = 0; i < Globals.colleges.length; i++){
	//	var college = Globals.colleges[i];
	//
	//	for (var j = 0; j < Globals.soireeTypes.length; j++){
	//		var soireeType = Globals.soireeTypes[j];
	//
	//		this.setCorrespondingTimeCount(soireeType, college, function(counts, _soireeType, _college){
	//			if (!timeCountsPerCollege[_college]) timeCountsPerCollege[_college] = {};
	//			if (!timeCountsPerCollege[_college][_soireeType]) timeCountsPerCollege[_college][_soireeType] = {};
	//
	//			timeCountsPerCollege[_csollege][_soireeType] = counts;
	//		});
	//
	//
	//	};
	//
	//}
}

soireeSchema.statics.setCorrespondingTimeCount = function (soireeType, callback) {
	this.countsForSoireeTypeAtTimes(soireeType, function (counts) {
		callback(counts, soireeType);
	});
};

soireeSchema.statics.countsForSoireeTypeAtTimes = function (soireeType, callback) {
	var Soiree = this;

	var availableTimes = Globals.availableTimesPerSoireeType[soireeType];

	var numToReturn = availableTimes.length;
	var numReturned = 0;
	var numErred = 0;
	var ans = {};

	var countCallback = function (err, count, atTime) {

		numReturned++;

		if (err) {
			numErred++;
			console.log(err);
			if (numErred === numToReturn) {
				return callback(null);
			}
		}
		else {
			ans[atTime] = count;
		}
		//console.log("count: " + count + " for " + atTime);
		//console.log(ans);

		if (numReturned === numToReturn) {
			console.log("returning " + ans);
			callback(ans);
		}
	};

	for (var i = 0; i < availableTimes.length; i++) {
		var timeString = availableTimes[i];

		this.performCountQuery(soireeType, timeString, countCallback);

	}
};

soireeSchema.statics.performCountQuery = function (soireeType, atTime, callback) {
	var Soiree = this;
	var date = DateHelper.dateFromTime(atTime);

	Soiree.count({soireeType: soireeType, date: date}, function (err, count) {
		callback(err, count, atTime);
	});

}


soireeSchema.statics.dateForSoireeType = function (soireeType) {
	var availableTimes = Globals.availableTimesPerSoireeType[soireeType];
	if (!availableTimes || availableTimes.length == 0) {
		return null;
	}
};

soireeSchema.statics.createSoireeWithType = function (soireeType, successCallback, errorCallback, options) {
	soireeType = soireeType.toLowerCase();

	if (soireeType === 'dinner') {
		var DinnerSoiree = require('app/db/DinnerSoiree.js');
		DinnerSoiree.createDinnerSoiree(successCallback, errorCallback, options);
	}
	else if (soireeType === 'drinks') {
		var DrinksSoiree = require('app/db/DrinksSoiree.js');
		DrinksSoiree.createDrinksSoiree(successCallback, errorCallback, options);
	}
	else if (soireeType === 'soiree_date') {
		var SoireeDateSoiree = require('app/db/SoireeDateSoiree.js');
		SoireeDateSoiree.createSoireeDateSoiree(successCallback, errorCallback, options);
	}
	else if (soireeType === 'movie') {
		var MovieSoiree = require('app/db/MovieSoiree.js');
		MovieSoiree.createMovieSoiree({movieName : "Test Movie"}, successCallback, errorCallback, options);
	}
	else if (soireeType === 'test') {
		this.createTest(successCallback, errorCallback);
	}
	else return errorCallback(ErrorCodes.InvalidInput);
};

soireeSchema.statics.createSoireeWithTypeForTests = function (soireeType, successCallback, errorCallback, options) {
	soireeType = soireeType.toLowerCase();

	if (soireeType === 'dinner') {
		var DinnerSoiree = require('app/db/DinnerSoiree.js');
		DinnerSoiree.createDinnerSoiree(successCallback, errorCallback, options);
	}
	else if (soireeType === 'drinks') {
		var DrinksSoiree = require('app/db/DrinksSoiree.js');
		DrinksSoiree.createDrinksSoiree(successCallback, errorCallback, options);
	}
	else if (soireeType === 'soiree_date') {
		var SoireeDateSoiree = require('app/db/SoireeDateSoiree.js');
		SoireeDateSoiree.createSoireeDateSoiree(successCallback, errorCallback, options);
	}
	else if (soireeType === 'movie') {
		var MovieSoiree = require('app/db/MovieSoiree.js');
		MovieSoiree.createMovieSoiree( {movieName : "Test Movie"}, successCallback, errorCallback, options);
	}
	else if (soireeType === 'test') {
		this.createTest(successCallback, errorCallback);
	}
	else return errorCallback(ErrorCodes.InvalidInput);
};



soireeSchema.statics.createTest = function (successCallback, errorCallback, options) {
	if (!options) options = {};

	var Soiree = this;

	var newDate;
	if (options.date) {
		newDate = options.date;
	}
	else {
		var today = new Date();
		var mins = today.getMinutes();
		var newMins = mins + (10 - (mins % 10));

		newDate = new Date();
		newDate.setMinutes(newMins);
	}


	var soireeType = "TEST";

	//determineDateForSoireeType(soireeType, college, function(date){
	//	if (!date) return errorCallback(ErrorCodes.NoAvailableDate);

	var soiree = new Soiree({
		soireeType: soireeType,
		date: newDate
	});

	Soiree.setSoireeDefaults(soiree, successCallback, errorCallback, options);
	//});

};

soireeSchema.statics.findSoireeWithId = function(soireeId, successCallback, errorCallback){
	this.findOne({soireeId : soireeId}).deepPopulate("_business").exec(function(err, soiree){
		if (err){
			console.log(err);
			errorCallback(ErrorCodes.MongoError);
		}
		else{
			successCallback(soiree);
		}
	});
};

soireeSchema.statics.findSoireesForUser = function (req, user, successCallback, errorCallback) {
	if (!user) {
		return errorCallback(ErrorCodes.InvalidInput);
	}

	var constraints = {
		"cancelled": false,
		"started": false,
		"ended": false,
		"_usersAttending": {"$ne": user._id},
		"_usersUncharged": {"$ne": user._id}
	};

	if (req.body.user && req.body.user.longitude && req.body.user.latitude) {
		var longitude = req.body.user.longitude;
		var latitude = req.body.user.latitude;
		var coors = LocationHelper.createPoint({longitude: longitude, latitude: latitude});

		constraints.location = {$near: coors};
	}

	var numSoireesToFetch = 25;

	var idsToIgnore = req.body.currentSoireesIds;

	if (idsToIgnore && idsToIgnore.length > 0) {
		//console.log("Ignoring soirees with ids in: " + idsToIgnore);
		constraints["soireeId"] = {'$nin': idsToIgnore};
	}

	this.find(constraints).deepPopulate("_business _usersAttending").limit(numSoireesToFetch).exec(function (err, soirees) {
		console.log('find returned');
		if (err) {
			console.log(err);
			errorCallback(err);
		}
		else {
			filterOutSoireesForUser(user, soirees, function (filteredSoirees) {
				console.log('calling successCallback');
				successCallback(filteredSoirees);
			});
		}
	});
};


//soireeSchema.statics.timeAtStringFromDate = function(date){
//	//var day = (24 + i) % 30;
//	//var date = new Date(2015, (10 - 1), day, 18, 30, 0);
//	var todaysDate = new Date();
//	var hour = date.getHours();
//	var minutes = date.getMinutes();
//
//	if (minutes < 10){
//		minutes = "0" + minutes.toString();
//	}
//
//	var amPm = "AM";
//	var when = "Today";
//
//	if (!DateHelper.isSameDay(todaysDate, date)){
//		if (DateHelper.isNextDay(todaysDate, date)){
//			when = "Tomorrow";
//		}
//		else when = DateHelper.dayFromDayNumber(date.getDay());
//	}
//	else if (hour > 18){
//		when = "Tonight";
//	}
//
//	if (hour > 12) {
//		hour -= 12;
//		amPm = "PM";
//	}
//	var timeAtString = when + " at " + hour + ":" + minutes + " " + amPm;
//	return timeAtString;
//};


//soireeSchema.statics.soireeTypes = function(){
//	return soireeTypes;
//};


soireeSchema.statics.findBySoireeId = function (soireeId, successCallback, errorCallback) {
	this.findOne({soireeId: soireeId}).populate('_business').exec(function (err, soiree) {
		if (err) {
			return errorCallback(err);
		}
		else if (!soiree) {
			return errorCallback();
		}
		else {
			successCallback(soiree);
		}
	});
};

soireeSchema.statics.joinSoireeWithId = function (soireeId, user, successCallback, errorCallback) {
	this.findBySoireeId(soireeId, function (soiree) {
		soiree.join(user, successCallback, errorCallback);
	}, function (err) {
		console.log(err);
		errorCallback(ErrorCodes.SoireeError);
	});
};


/* Methods */

soireeSchema.methods.remind = function (mins) {
	if (!mins) {
		var todaysDate = new Date();
		var diff = this.date - todaysDate;//in ms
		mins = parseInt(diff / (1000 * 60));
	}
	if (mins > 0) {
		var soiree = this;

		this.deepPopulate("_usersAttending", function (err) {
			if (err) {
				return console.log(err);
			}
			console.log("Reminding users of soiree " + soiree.soireeType + " " + soiree.scheduledStartTimeIdentifier + " ...");

			for (var i = 0; i < soiree._usersAttending.length; i++) {
				var user = soiree._usersAttending[i];
				Notification.createSoireeReminderNotification(soiree, user, mins);
			}
		});

	}
};

soireeSchema.methods.startIfPossible = function () {
	if (!this.started && !this.cancelled && !this.ended) {
		if (!this.openToUsers) {
			this.open();
		}

		this.deepPopulate("_host", function (err, soiree) {
			if (err) {
				console.log(err);
			}

			var todaysDate = new Date();
			var numMinsPassed = (todaysDate - soiree.date) / (60 * 1000);

			var canStart = numMinsPassed >= -1;
			var timeWaitingUp = numMinsPassed >= 5;
			console.log("startIfPossible with canStart: " + canStart + " timeWaitingUp " + timeWaitingUp + " numMinsPassed: " + numMinsPassed);

			if (canStart) {
				if (!timeWaitingUp) {
					//start if numUsersMin are here
					if (soiree._host._usersJoined.length >= soiree.numUsersMin) {
						soiree.start();
					}
					//else keep waiting for new users to join or time limit to be up
				}
				else {
					if (soiree._host._usersJoined.length >= 2) {
						soiree.start();
					}
					else {
						//else, don't start, apologize to only user there, then cancel
						soiree.cancel();
					}
				}
			}
			else {
				//if everyone is here
				if (soiree._host._usersJoined.length >= soiree._usersAttending.length) {
					soiree.start();
				}
			}
		});
	}
};

soireeSchema.methods.start = function () {
	if (!this.cancelled && !this.ended) {
		if (!this.openToUsers) {
			this.open();
		}

		this.deepPopulate("_usersAttending _host", function (err, soiree) {
			if (err) {
				console.log(err);
			}

			console.log("Starting soiree " + soiree.soireeType + " " + soiree.scheduledStartTimeIdentifier + " with num users attending: " + soiree._usersAttending.length + " ...");

			alertUsersThatSoireeStarted(soiree);

			soiree.started = true;
			soiree.inProgress = true;
			soiree._host.start();

			soiree.save(Globals.saveErrorCallback);
		});
	}
};


soireeSchema.methods.end = function () {
	if (this.started && !this.ended) {

		console.log("Ending soiree " + this.soireeType + " " + this.scheduledStartTimeIdentifier + " with users attending length: " + this._usersAttending.length + " ...");
		var soiree = this;

		this.deepPopulate("_usersAttending", function (err) {
			if (err) {
				console.log("Error ending soiree: " + err);
			}
			else {
				for (var i = 0; i < soiree._usersAttending.length; i++) {
					var user = soiree._usersAttending[i];
					user.endedSoiree(soiree);
				}
			}
			soiree.ended = true;
			soiree.inProgress = false;
			soiree.openToUsers = false;

			soiree.save(Globals.saveErrorCallback);
		});
	}
};

soireeSchema.methods.open = function () {
	if (this.reachedNumUsersMin && !this.openToUsers) {
		this.openToUsers = true;

		if (!this._host) {
			var SoireeHost = mongoose.model('SoireeHost');

			var host = new SoireeHost({
				_soiree: this._id,
				roomId: this.soireeId
			});
			console.log('created host: ' + host);
			this._host = host._id;
			host.save(Globals.saveErrorCallback);
		}

		this.save(function (err) {
			if (err) {
				console.log("Error opening soiree: " + err);
			}
		});
	}
};

soireeSchema.methods.cancelSoireeIfNecessary = function () {
	if (!this.reachedNumUsersMin && !this.cancelled) {
		//cancel soiree
		this.cancel();
	}
};

soireeSchema.methods.cancel = function () {
	if (!this.cancelled && !Globals.soireesCancelling[this.soireeId]) {
		console.log("cancelling soiree " + this.soireeId);
		Globals.soireesCancelling[this.soireeId] = true;

		this.deepPopulate("_chargedReservations _usersUncharged _usersAttending _business", function (err, soiree) {
			if (err) {
				return console.log(err)
			};

			//if (Globals.numSoireesHostedPerBusiness[soiree._business.businessId]) {
			//	Globals.numSoireesHostedPerBusiness[soiree._business.businessId]--;
			//}


			//notify users of cancellation
			for (var i = 0; i < soiree._usersUncharged.length; i++) {
				var user = soiree._usersUncharged[i];
				user.notifyOfSoireeCancellation(soiree);
				user.cancelledSoiree(soiree);
			}
			for (var a = 0; a < soiree._usersAttending.length; a++) {
				var user = soiree._usersAttending[a];
				user.notifyOfSoireeCancellation(soiree);
				user.cancelledSoiree(soiree);
			}
			//double check that no users were charged. if so, refund them
			//if (this._chargedReservations.length > 0){
			for (var j = 0; j < soiree._chargedReservations.length; j++) {
				var reservation = soiree._chargedReservations[j];
				reservation.refund();
			}
			//}
			//set cancelled to true and save
			soiree.cancelled = true;
			soiree.openToUsers = false;

			soiree._business.cancelledSoiree(soiree);

			soiree.save(function (err) {
				if (err) {
					console.log(err);
				}
				Globals.soireesCancelling[this.soireeId] = null;
			});
		});
	}
};

soireeSchema.methods.hasUserAlreadyJoined = function (user) {
	if (user) {
		var soiree = this;

		var keys = ["_usersAttending", "_usersUncharged"];
		for (var k = 0; k < keys.length; k++) {
			var key = keys[k];

			if (soiree.populated(key)) {
				for (var i = 0; i < soiree[key].length; i++) {
					var curr = soiree[key][i];

					if (curr._id.equals(user._id)) {
						return true;
					}
				}
			}

			else {
				if (soiree[key].indexOf(user._id) !== -1){
					return true;
				}
			}
		}

	}

	return false;
};

soireeSchema.statics.addNewReservationForId = function(_id, reservation){

	_id = _id._id ? _id._id : _id; //chance that object passed in is actually populated doc. if so get its _id
	var updateQuery;

	if(!reservation.charged){
		updateQuery = {$addToSet : { _unchargedReservations : reservation._id, _usersUncharged : reservation._user}};
	}
	else{
		updateQuery = {$addToSet : { _chargedReservations : reservation._id, _usersAttending : reservation._user}};
	}

	return this.findOneAndUpdate({_id : _id}, updateQuery, {new : true}).exec();
};

soireeSchema.statics.chargedUnchargedReservationForId = function(_id, reservation){
	_id = _id._id ? _id._id : _id; //chance that object passed in is actually populated doc. if so get its _id
	var updateQuery;
	var Soiree = this;
	updateQuery = { $pull : {_unchargedReservations : reservation._id, _usersUncharged : reservation._user } };

	this.findOneAndUpdate({_id : _id}, updateQuery, {new : true}, function(err, newDoc){
		if (err){
			console.log(err);
		}
		Soiree.addNewReservationForId(_id, reservation);
	});

};



soireeSchema.methods.join = function (user, successCallback, errorCallback) {
	var soiree = this;
	if (soiree.cancelled) return errorCallback(ErrorCodes.SoireeExpired);
	if (soiree.inProgress) return errorCallback(ErrorCodes.SoireeStarted);
	if (soiree.ended) return errorCallback(ErrorCodes.SoireeExpired);
	if (soiree.full) return errorCallback(ErrorCodes.SoireeFull);

	if (!user.chargeable && !(user.testUser && Globals.devOrTest)) {
		return errorCallback(ErrorCodes.Error);
	}
	if (this._usersAttending.indexOf(user._id) != -1 || this._usersUncharged.indexOf(user._id) != -1) {
		//user has already joined soiree
		return errorCallback(ErrorCodes.UserAlreadyJoinedSoiree);
	}


	shouldShowSoireeForUser(user, this, function () {
		//user can join
		//see if you should charge him now
		var SoireeReservation = mongoose.model("SoireeReservation");

		if (soiree.willReachNumUsersMin || soiree.reachedNumUsersMin) {
			if (soiree._unchargedReservations.length > 0 || soiree._usersUncharged.length > 0) {
				soiree.chargeUnchargedUsers();
			}
			SoireeReservation.createChargedSoireeReservation(user, soiree, successCallback, errorCallback);
		}
		else {
			SoireeReservation.createUnchargedSoireeReservation(user, soiree, successCallback, errorCallback);
		}
	}, function () {
		//user can't join
		return errorCallback(ErrorCodes.SoireeGenderError);
	});


};

soireeSchema.methods.chargeUnchargedUsers = function () {

	console.log("In chargeUnchargedUses() : Charging " + this._unchargedReservations.length + " users...");
	//console.log(this._unchargedReservations);

	this.deepPopulate("_unchargedReservations._user", function (err, soiree) {
		if (err) {
			return console.log("ERROR POPULATING: " + err);
		}

		soiree._unchargedReservations.forEach(function (reservation) {
			console.log("charging reservation " + reservation.reservationId);

			if (!reservation.charged) {
				reservation.chargeUser(function (user) {
					console.log("Successfully charged " + user.fullName);
					Notification.createSoireeConfirmedNotification(soiree, user);
				}, function (err) {
					console.log("Error charging user " + reservation._user.fullName + " : " + err);
				});
			}

		});

	});

};

soireeSchema.methods.createDescription = function () {
	var soireeType = this.soireeType.toLowerCase();
	var description = "";

	var numOtherUsers = (this.numUsersMax - 1) + "";

	if (soireeType === "lunch") {
		description =
			"Come grab lunch with " + numOtherUsers +
			" other amazing people! Eat delicious food while " +
			"playing games and chatting with soon-to-be new friends. Not sure how to break the ice? " +
			"We'll do all the work, don't worry.";
	}
	else if (soireeType === "dinner") {
		description =
			"Come grab dinner with " + numOtherUsers +
			" other amazing people! Eat delicious food while " +
			"playing games and chatting with soon-to-be new friends. Not sure how to break the ice? " +
			"We'll do all the work, don't worry.";

	}
	else if (soireeType === "drinks") {
		description =
			"Come grab drinks with " + numOtherUsers +
			" other amazing people! Drink quality alcoholic drinks while " +
			"playing games and chatting with soon-to-be new friends. Not sure how to break the ice? " +
			"We'll do all the work, don't worry.";
	}
	else if (soireeType === "blind date") {
		description =
			"Want to meet a new love interest, but not sure how? Worried about all the creeps out there," +
			"or about the date being boring? Try a " + this.SOIREE + " blind date! " +
			"We'll make sure the person on the other end is not a creep, and the date is exciting. Not sure how to break the ice? " +
			"We'll do all the work, don't worry.";
	}
	return description;
};

soireeSchema.statics.determineDateForSoireeType = function (soireeType, callback) {

	soireeType = soireeType.toLowerCase();

	console.log("determining date for soiree type " + soireeType);
	var dateCallback = function (counts) {
		if (!counts || counts.length === 0) return callback(null);

		var minDate = new Date(Date.now() + MIN_TIME_BEFORE_CAN_CREATE_SOIREE);

		var availableTimes = Globals.availableTimesPerSoireeType[soireeType];
		//console.log("available times: " + availableTimes);

		var minTime;
		var min = -1;

		if (minDate <= DateHelper.dateFromTime(availableTimes[0])) {
			minTime = availableTimes[0];
			min = counts[minTime];
		}

		for (var i = 1; i < availableTimes.length; i++) {
			var curr = availableTimes[i];
			//console.log('comparing ' + counts[curr] + '(' + curr + ') with curr min: ' + min + "(" + minTime + ")");

			if ((min === -1 || counts[curr] < min) && minDate <= DateHelper.dateFromTime(curr)) {
				min = counts[curr];
				minTime = curr;
			}
		}

		if (!minTime) return callback(null);
		//console.log("final ans: " + minTime);
		var ans = DateHelper.dateFromTime(minTime);
		console.log("Date determined: " + ans.toString());
		return callback(ans);
	};


	if (!timeCountsPerSoireeType[soireeType]) {
		this.countsForSoireeTypeAtTimes(soireeType, function (counts) {
			timeCountsPerSoireeType[soireeType] = counts;
			dateCallback(counts);
		});
	}
	else {
		var counts = timeCountsPerSoireeType[soireeType];
		dateCallback(counts);
	}

};

function alertUsersThatSoireeStarted(soiree) {
	for (var i = 0; i < soiree._usersAttending.length; i++) {
		var user = soiree._usersAttending[i];
		Notification.createSoireeStartingNotification(soiree, user);
	}
};

function filterOutSoireesForUser(user, soirees, callback) {
	var ans = [];
	var numReturned = 0;
	if (!callback) return;

	if (!soirees || soirees.length == 0){
		return callback([]);
	}

	for (var i = 0; i < soirees.length; i++) {
		var soiree = soirees[i];

		shouldShowSoireeForUser(user, soiree, function () {
			ans.push(soiree);

			if (++numReturned === soirees.length) {
				return callback(ans);
			}

		}, function () {
			if (++numReturned === soirees.length) {
				return callback(ans);
			}
		});
	}

};

function shouldShowSoireeForUser(user, soiree, trueCallback, falseCallback) {

	falseCallback = falseCallback ? falseCallback : function () {
	};
	trueCallback = trueCallback ? trueCallback : function () {
	};

	var maxRatioStr = Globals.minMaleToFemaleRatios[soiree.soireeType];
	if (!maxRatioStr) {
		return trueCallback();
	}

	if (Globals.numUsersMinPerSoireeType[soiree.soireeType] && soiree._users.length < Globals.numUsersMinPerSoireeType[soiree.soireeType] / 2.) {//not enough users to start enforcing ratio. accept soiree
		return trueCallback();
	}
	//else enough users have joined to start enforcing ratio

	soiree.deepPopulate("_usersAttending _usersUncharged", function (err, _soiree) {
		if (err) {
			console.log(err);
			return falseCallback();
		}

		var numMales = 0;
		var numFemales = 0;

		console.log("1 numMales: " + numMales + ", numFemales : " + numFemales);

		for (var j = 0; j < _soiree._users.length; j++) {
			var currUser = _soiree._users[j];

			if (currUser.isMale) {
				numMales++;
			}
			else if (currUser.isFemale) {
				numFemales++;
			}
		}

		var maxRatio = math.eval(maxRatioStr);
		var soireeRatio = -1;
		console.log("2 soireeRatio : " + soireeRatio + ", numMales: " + numMales + ", numFemales : " + numFemales + ", maxRatio : " + maxRatio);


		if (user.isMale) {
			if (numFemales !== 0) {
				soireeRatio = numMales / numFemales;
			}
		}
		else {
			if (numMales !== 0) {
				soireeRatio = numFemales / numMales;
			}
		}

		console.log("3 soireeRatio : " + soireeRatio + ", numMales: " + numMales + ", numFemales : " + numFemales + ", maxRatio : " + maxRatio);
		if (soireeRatio !== -1 && maxRatio >= soireeRatio) {//good
			return trueCallback();
		}
		else {//bad
			return falseCallback();
		}
	});

};


/* Virtuals */

soireeSchema.virtual('full').get(function () {
	return this.numUsersAttending >= this.numUsersMax;
});

soireeSchema.virtual('SOIREE').get(function () {
	return "Soirée";
});

soireeSchema.virtual('reachedNumUsersMin').get(function () {
	return this.totalNumUsers >= this.numUsersMin;
});

soireeSchema.virtual('willReachNumUsersMin').get(function () {
	return this.totalNumUsers === this.numUsersMin - 1;
});

soireeSchema.virtual('numUsersAttending').get(function () {
	return this._usersAttending.length;
});
soireeSchema.virtual('totalNumUsers').get(function (num) {
	return this._usersAttending.length + this._usersUncharged.length;
});

soireeSchema.virtual('inProgress').get(function () {
	return this.started && !this.ended;
});

soireeSchema.virtual('_users').get(function () {
	return this._usersAttending.concat(this._usersUncharged);
});

soireeSchema.virtual('businessAddress').get(function () {
	if (this.populated("_business") && this._business){
		return this._business.address;
	}
	return null;
});

soireeSchema.pre("save", function (next) {

	if (!this.scheduledStartTimeIdentifier) {
		this.scheduledStartTimeIdentifier = this.constructor.createScheduledTimeIdentifier(this.date);
	}
	if (!this.scheduledEndTimeIdentifier) {
		this.scheduledEndTimeIdentifier = this.constructor.createScheduledTimeIdentifier(new Date(this.date.getTime() + (this.duration * 60 * 1000)));
	}
	if (!this.numUsersMax) {
		this.numUsersMax = Globals.numUsersMaxPerSoireeType[this.soireeType];
	}
	if (!this.initialCharge) {
		this.initialCharge = Globals.initialChargePerSoireeType[this.soireeType];
	}
	if (!this.soireeDescription) {
		this.soireeDescription = this.createDescription();
	}
	if (!this.title){
		this.title = capitalizeAndClean(this.soireeType);
	}

	next();
});

soireeSchema.post("init", function (soiree) {

});

var deepPopulate = require('mongoose-deep-populate')(mongoose);
var options = {};
soireeSchema.plugin(deepPopulate, options);
soireeSchema.plugin(autopopulate);


//function Soiree(){
//	this.call(this);
//}


//util.inherits(SoireeSchema, Schema);

//var soireeSchema = new SoireeSchema();

var SoireeModel = mongoose.model('Soiree', soireeSchema);
module.exports = SoireeModel;
module.exports.schema = soireeSchema;

//module.exports.constructor = SoireeSchema;

SoireeModel.fillTimeCountsPerSoireeType();

